#version 430 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform image2D outputImage;

const int MAX_RECURSION_DEPTH = 4;
const float SHADOW_BIAS = 0.005;
const vec3 BACKGROUND_COLOR = vec3(0.05, 0.08, 0.15);
const vec3 FLOOR_COLOR_A = vec3(0.8);
const vec3 FLOOR_COLOR_B = vec3(0.5);
const vec3 BOX_COLOR = vec3(0.1, 0.12, 0.18);
const float GLOBAL_AMBIENT = 0.25;

struct ShaderPhysicsObject {
    vec3 position;
    float radius;
    vec3 color;
    float reflectivity;
};

struct PointLight {
    vec3 position;
    float intensity;
    vec3 color;
    float padding;
};

struct GpuGridCell {
    uint objectStartIndex;
    uint objectCount;
};

layout (std140, binding = 1) readonly buffer ObjectsBuffer {
    ShaderPhysicsObject objects[];
};
layout (std140, binding = 2) readonly buffer LightsBuffer {
    PointLight lights[];
};
layout (std140, binding = 3) readonly buffer GpuGridCellsBuffer {
    GpuGridCell gpuGridCells[];
};
layout (std140, binding = 4) readonly buffer GpuObjectIndicesBuffer {
    uint gpuObjectIndices[];
};

uniform int numObjects;
uniform int numLights;

uniform vec3 cameraPos;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;

uniform int gridCellsX;
uniform int gridCellsY;
uniform int gridCellsZ;
uniform float cellSize;
uniform vec3 worldDimensions;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct TraceResult {
    bool hit;
    float distance;
    vec3 hitPoint;
    vec3 normal;
    int hitType; // 0: None, 1: Sphere, 2: Floor, 3: Box
    vec3 color;
    float reflectivity;
    int objectIndex;
};

float intersectSphere(Ray r, vec3 spherePos, float sphereRadius) {
    vec3 oc = r.origin - spherePos;
    float a = dot(r.direction, r.direction);
    float b = 2.0 * dot(oc, r.direction);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return 1e30;
    } else {
        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t0 > 0.001) return t0;
        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
        if (t1 > 0.001) return t1;
        return 1e30;
    }
}

float intersectPlane(Ray r, vec3 planeNormal, float planeOffset) {
    float denom = dot(r.direction, planeNormal);
    if (abs(denom) > 1e-6) {
        float t = (planeOffset - dot(r.origin, planeNormal)) / denom;
        if (t > 0.001) {
            return t;
        }
    }
    return 1e30;
}

int get1DIndex(ivec3 coords) {
    return coords.x + coords.y * gridCellsX + coords.z * gridCellsX * gridCellsY;
}

bool isValidCell(ivec3 coords) {
    return coords.x >= 0 && coords.x < gridCellsX &&
           coords.y >= 0 && coords.y < gridCellsY &&
           coords.z >= 0 && coords.z < gridCellsZ;
}

TraceResult findClosestHit(Ray r) {
    TraceResult result;
    result.hit = false;
    result.distance = 1e30;
    result.hitType = 0;

    vec3 gridMinWorld = vec3(0.0);
    vec3 gridMaxWorld = worldDimensions;
    
    vec3 invDir = 1.0 / r.direction;
    vec3 t0s = (gridMinWorld - r.origin) * invDir;
    vec3 t1s = (gridMaxWorld - r.origin) * invDir;
    vec3 tmin = min(t0s, t1s);
    vec3 tmax = max(t0s, t1s);
    float t_enter_grid = max(max(tmin.x, tmin.y), tmin.z);
    float t_exit_grid = min(min(tmax.x, tmax.y), tmax.z);

    if (t_enter_grid < t_exit_grid && t_exit_grid > 0.0) {
        vec3 traversalRayOrigin = r.origin + r.direction * max(0.0, t_enter_grid);
        ivec3 currentCellCoords = ivec3(floor(traversalRayOrigin / cellSize));
        vec3 stepDir = sign(r.direction);
        vec3 tDelta = abs(vec3(cellSize) / r.direction);

        vec3 nextBoundary;
        nextBoundary.x = (r.direction.x > 0) ? (float(currentCellCoords.x + 1) * cellSize) : (float(currentCellCoords.x) * cellSize);
        nextBoundary.y = (r.direction.y > 0) ? (float(currentCellCoords.y + 1) * cellSize) : (float(currentCellCoords.y) * cellSize);
        nextBoundary.z = (r.direction.z > 0) ? (float(currentCellCoords.z + 1) * cellSize) : (float(currentCellCoords.z) * cellSize);

        vec3 tMax;
        tMax.x = (r.direction.x != 0) ? (nextBoundary.x - traversalRayOrigin.x) / r.direction.x : 1e30;
        tMax.y = (r.direction.y != 0) ? (nextBoundary.y - traversalRayOrigin.y) / r.direction.y : 1e30;
        tMax.z = (r.direction.z != 0) ? (nextBoundary.z - traversalRayOrigin.z) / r.direction.z : 1e30;
        
        for (int step = 0; step < 500; ++step) {
            if (!isValidCell(currentCellCoords)) break;
            
            int cellIdx = get1DIndex(currentCellCoords);
            if (cellIdx >= 0 && cellIdx < (gridCellsX * gridCellsY * gridCellsZ)) {
                GpuGridCell cell = gpuGridCells[cellIdx];
                for (uint i = 0; i < cell.objectCount; ++i) {
                    uint objIdx = gpuObjectIndices[cell.objectStartIndex + i];
                    float dist = intersectSphere(r, objects[objIdx].position, objects[objIdx].radius);
                    if (dist < result.distance) {
                        result.hit = true;
                        result.distance = dist;
                        result.objectIndex = int(objIdx);
                        result.hitType = 1;
                    }
                }
            }
            
            float nextT = min(min(tMax.x, tMax.y), tMax.z);
            if (result.distance < max(0.0, t_enter_grid) + nextT) break;

            if (tMax.x < tMax.y) {
                if (tMax.x < tMax.z) { currentCellCoords.x += int(stepDir.x); tMax.x += tDelta.x; } 
                else { currentCellCoords.z += int(stepDir.z); tMax.z += tDelta.z; }
            } else {
                if (tMax.y < tMax.z) { currentCellCoords.y += int(stepDir.y); tMax.y += tDelta.y; }
                else { currentCellCoords.z += int(stepDir.z); tMax.z += tDelta.z; }
            }
        }
    }

    float floorDist = intersectPlane(r, vec3(0, 1, 0), 0);
    if (floorDist < result.distance) {
        result.hit = true;
        result.distance = floorDist;
        result.hitType = 2;
    }
    
    if (t_enter_grid > 0.0 && t_enter_grid < result.distance) {
        result.hit = true;
        result.distance = t_enter_grid;
        result.hitType = 3;
    }

    if (result.hit) {
        result.hitPoint = r.origin + r.direction * result.distance;
        if (result.hitType == 1) { // Sphere
            result.normal = normalize(result.hitPoint - objects[result.objectIndex].position);
            result.color = objects[result.objectIndex].color;
            result.reflectivity = objects[result.objectIndex].reflectivity;
        } else if (result.hitType == 2) { // Floor
            result.normal = vec3(0, 1, 0);
            vec2 c = floor(result.hitPoint.xz / (cellSize*2.0));
            result.color = mod(c.x + c.y, 2.0) == 0 ? FLOOR_COLOR_A : FLOOR_COLOR_B;
            result.reflectivity = 0.2;
        } else if (result.hitType == 3) { // Box
            vec3 c = (result.hitPoint - (gridMaxWorld + gridMinWorld) / 2.0);
            vec3 d = (gridMaxWorld - gridMinWorld) / 2.0;
            vec3 p = c / d;
            vec3 a = abs(p);
            result.normal = -sign(r.direction) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);
            result.color = BOX_COLOR;
            result.reflectivity = 0.0;
        }
    }
    return result;
}

vec3 shade(TraceResult res, Ray r) {
    vec3 viewDir = -r.direction;
    vec3 ambient = GLOBAL_AMBIENT * res.color;
    vec3 lighting = ambient;

    for (int i = 0; i < numLights; ++i) {
        vec3 lightDir = lights[i].position - res.hitPoint;
        float lightDist = length(lightDir);
        lightDir = normalize(lightDir);

        Ray shadowRay = { res.hitPoint + res.normal * SHADOW_BIAS, lightDir };
        TraceResult shadowRes = findClosestHit(shadowRay);
        
        if (shadowRes.hit && shadowRes.distance < lightDist) {
            continue;
        }

        float lambertian = max(dot(lightDir, res.normal), 0.0);
        vec3 diffuse = lambertian * res.color * lights[i].color * lights[i].intensity;

        vec3 halfVec = normalize(lightDir + viewDir);
        float specAngle = max(dot(halfVec, res.normal), 0.0);
        float specular = pow(specAngle, 32.0);
        vec3 specColor = specular * lights[i].color * lights[i].intensity * 0.5;
        
        lighting += diffuse + specColor;
    }
    return lighting;
}

vec3 trace(Ray r) {
    vec3 finalColor = vec3(0.0);
    vec3 rayColorAttenuation = vec3(1.0);

    for (int depth = 0; depth < MAX_RECURSION_DEPTH; ++depth) {
        TraceResult res = findClosestHit(r);

        if (!res.hit) {
            finalColor += BACKGROUND_COLOR * rayColorAttenuation;
            break;
        }

        finalColor += shade(res, r) * rayColorAttenuation * (1.0 - res.reflectivity);
        
        if (res.reflectivity <= 0.0) {
            break;
        }

        r.origin = res.hitPoint + res.normal * SHADOW_BIAS;
        r.direction = reflect(r.direction, res.normal);
        rayColorAttenuation *= res.reflectivity;
    }
    return finalColor;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    
    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize.x, imageSize.y);
    vec2 screenPos = uv * 2.0 - 1.0;

    vec4 clipPos = vec4(screenPos, 1.0, 1.0);
    vec4 eyePos = projectionInverse * clipPos;
    eyePos /= eyePos.w;

    Ray r;
    r.origin = cameraPos;
    r.direction = normalize(vec3(viewInverse * eyePos));
    
    vec3 finalColor = trace(r);

    imageStore(outputImage, pixelCoords, vec4(clamp(finalColor, 0.0, 1.0), 1.0));
}
