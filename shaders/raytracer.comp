#version 430 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform writeonly image2D outputImage;

uniform vec3 cameraPos;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;
uniform vec3 worldDimensions;

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    
    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }

    // 1. Generate the Ray (Same logic as before)
    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize.x, imageSize.y);
    vec2 screenPos = uv * 2.0 - 1.0;
    vec4 clipPos = vec4(screenPos, 1.0, 1.0);
    vec4 viewPos = projectionInverse * clipPos;
    viewPos /= viewPos.w;
    vec4 worldPos = viewInverse * viewPos;
    vec3 rayDir = normalize(vec3(worldPos) - cameraPos);

    // 2. Perform the AABB intersection test (Slab Test)
    vec3 invDir = 1.0 / rayDir;
    vec3 tNearPlanes = (vec3(0.0) - cameraPos) * invDir;
    vec3 tFarPlanes = (worldDimensions - cameraPos) * invDir;
    vec3 tMin = min(tNearPlanes, tFarPlanes);
    vec3 tMax = max(tNearPlanes, tFarPlanes);
    float tEnter = max(max(tMin.x, tMin.y), tMin.z);
    float tExit = min(min(tMax.x, tMax.y), tMax.z);

    // 3. Visualize the result
    vec3 finalColor = vec3(0.0, 0.0, 1.0); // Blue for "miss"
    if (tEnter < tExit && tExit >= 0.0) {
        finalColor = vec3(1.0, 0.0, 0.0); // Red for "hit"
    }

    imageStore(outputImage, pixelCoords, vec4(finalColor, 1.0));
}
